def find_set(v,p):
    if (v == p[v]):
        return v
    p[v] = find_set(p[v], p) # сжимаем дерево, длину преобразуем в ширину, все прошедшие вершинки привязываем к руту
    return p[v]

# первоначально все вершины находятся в собственном мн-ве
# поэтому рут = вершинка и размер мн-ва = 1
def make_set(v, p, sz):
    p[v] = v
    sz = 1

def union_set(a,b, p, sz): #даны две в-ны которые надо объединить
    a = find_set(a, p) #узнаем мн-во а
    b = find_set(b, p) #узнаем мн-во b
    if a!=b: #если они из разных мн-в
        if sz[a] < sz[b]: #узнаем меньшее для оптимальности слияния
            a,b = b,a
        p[b] = a #теперь предок b=a, откуда множества объединились с общим рутом=а
        sz[a] += sz[b] #обновляем общий размер (размер прикреплен к руту=а)


n, m = map( int, input().split()) # вводим кол-во вершин и ребер
edges = [] # создаем матрицу ребер

for _ in range(m):
    u, v, w = map(int, input().split()) # вводим соединенные вершины и вес ребра
    u -= 1
    v -= 1
    edges.append((w, (u,v))) # добавляем 3ку вес и соед-ые в-ны
edges.sort() # сортируем по весу ребра (3ки)

p = [0] * n
sz = [0] * n
for i in range(n):
    make_set(i, p, sz)

ans = 0
for i in range(len(edges)): # проходим циклом по ребрам от самого легкого
    w, (u,v) = edges[i] # получаем значения веса и в-н
    u = find_set(u,p) # узнаем множество u
    v = find_set(v,p) # узнаем в какое мн-во входит v
    if u==v: # если они из одного множества
        continue # то скипаем
    ans += w # если нет, то добавляем в ответ вес ребра (оставляем его)
    union_set(u,v,p,sz) # объединяем u и v в одно мн-во(дерево), тк провели ребро

print(ans)
