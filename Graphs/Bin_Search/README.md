# Бинарный поиск в графах
мы ищем путь на котором максимум из чисел, соответствующих ребрам, минимален

максимум из чисел, соответствующих ребрам - Т
```cpp
int n,m,d;
const int INF = 1e9+7;
vector<vpii> graph;
// мы ищем путь на котором максимум из чисел, соответствующих ребрам, минимален
// максимум из чисел, соответствующих ребрам - Т
bool ok(int T){
    vi dist(n+1, INF); // вектор с расс-ми (кол-ом ребер)
    dist[1]=0;
    forn(v,1,n+1){
        for (auto [to, cost]: graph[v]){
            if (cost <= T && dist[v] != INF) // проходимся по стоимости дорог
                dist[to] = min(dist[to], dist[v]+1);
        }
    }
    return (dist[n] <= d); // если с макс стои-ью = Т путь находится, то можно и понизить
}

vi build_path(int T){
    vi dist(n+1, INF), parent(n+1, -1); // вектор расс-ий и связей вершин
    dist[1]=0;

    forn(v,1,n+1){
        if (dist[v] == INF)
            continue;
        for(auto [to, cost] : graph[v]) {
            if (cost <= T && dist[to] > dist[v]+1){ // воспроизводим путь из ОК
                dist[to] = dist[v] +1;
                parent[to] = v; // если берем вершинку, то записываем в путь из род-ей
            }
        }
    }
    if (dist[n] > d) // если, путь не получился, то скидываем пустой
        return {};

    vi path;
    for( int cur=n; cur!=-1; cur=parent[cur]) // создаем ответный массив поочередности в-н
        path.pb(cur); // начинаем с конечной в-ны и идем по родителям

    reverse(all(path)); // переворачиваем массив
    return path;
}

void solve(){
    cin>>n>>m>>d; //кол-во перекрестков, односторонних дорог, ребер на пути от 1 до н
    graph.assign(n+1, {}); // инициализируем граф


    forn(i,0,m){ // заполняем граф
        int a,b,c;
        cin>>a>>b>>c;
        graph[a].pb({b,c}); // у в-ны а есть ребро к b стоимостью c
    }

    
    vi dist(n+1,INF); // создаем вектор расстояний
    dist[1]=0; // расстояние от 1ой в-ны до 1 в-ны = 0
    forn(v,1,n+1){ // цикл для подсчета расстояний от 1ой до ной в-ны
        if (dist[v] == INF) // если раст-ие неопр-но, то это отдельная в-на? или еще не рассчитаная?
            continue;
        for (auto [to, cost] : graph[v]) // проходимся по соседним в-нам
            dist[to] = min(dist[to], dist[v]+1); // ставим мин расстояние
    }
    if (dist[n] > d){ // если кол-во ребер слишком большое
        cout<<-1<<en; // недобратся
        return;
    }
    // бин поиск по ответу
    int l = 0, r=1e9;
    while(l<r){
        int mid = (l+r)>>1;
        if (ok(mid)) // если ок, то уменьшаем макисмум-Т
            r = mid;
        else
            l = mid+1;
    }

    vi path = build_path(l);
    cout<<(int)path.size()-1<<en;
    for (int v: path) cout<<v<<' ';

}
```
