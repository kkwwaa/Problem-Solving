# Suffix array

Суффиксный массив (SA) строки s длины n — это массив индексов p[0..n], задающий порядок всех суффиксов строки (с добавленным символом $).

## Алгоритм построения (метод удвоения)
- Добавляем $ (меньше всех символов).
- p — порядок суффиксов, c — классы эквивалентности (ранги).
- k=0: сортируем по первому символу.
- Для каждого шага k→k+1:
    - сдвигаем позиции на 2^k;
    - сортируем по классам (count_sort);
    - пересчитываем классы по парам (c[i], c[i+2^k]).
- Стоп, когда 2^k ≥ n.

**Время: O(n log n).**

## Зачем нужен
- Быстрый поиск подстроки через бинарный поиск по p.
- Иcпользуется для LCP массива (длины общих префиксов соседних суффиксов).
- Применение: строки, поиск, сжатие, suffix tree.


```cpp
// Стабильная сортировка по классам (counting sort)
void count_sort(vector<int>& p, const vector<int>& c) {
    int n = (int)p.size(); // н - длина строки
    vi cnt(n), p_new(n); // создаем массив для счета и новый р

    for (int x : c) cnt[x]++; // проходимся по с и считаем сколько какого ранга

    vi pos(n); // создаем массив позиций
    pos[0] = 0; // ставим 0ой эл-т
    forn(i,1,n) pos[i] = pos[i-1] + cnt[i-1]; // pos[cl] = "куда вставлять следующий элемент этого класса в p_new"
    // Это как в сортировке подсчётом: сначала считаем частоты, потом префиксные суммы → получаем позиции.

    for (int x : p) { // проходим по p = [6, 5, 0, 2, 4, 1, 3]
        int cl = c[x]; // класс элемента x
        p_new[pos[cl]++] = x;   // ставим x в "своё место" для класса cl и двигаем указатель вперёд
    }
    p.swap(p_new); // заменяем р новым-р
}

vi build_sa(string s) {
    s.pb('$'); // добавляем сим-л в конец строки
    int n = (int)s.size(); // в н длина данной строки

    vi p(n), c(n); // создаем массивы с и р

    // почему сорт-ка при к=0 отдельно?
    {
        vector<pair<char,int>> a(n); // создаем массив пар (буква, индекс)
        forn(i,0,n) a[i] = {s[i], i}; // заполняем его по строке
        sort(all(a)); // сортим по буквам
        forn(i,0,n) p[i] = a[i].second; // заполняем р
        c[p[0]] = 0; // проставляем классы и начинаем с первого - $
        forn(i,1,n) {
            if (a[i].first == a[i-1].first) c[p[i]] = c[p[i-1]]; // если буквы равны, то ставим один ранг
            else c[p[i]] = c[p[i-1]] + 1; // нет - повышаем ранг
        }
    }

    int k = 0;
    while ((1 << k) < n) { // что это 1 << k типо к/2?
        // сдвигаем позиции на 2^k влево // ладно, этот прикол со степенями и битовыми сдвигами я еще не совсем понимаю(((
        forn(i,0,n) {
            p[i] = (p[i] - (1 << k) + n) % n; // происходит какая-то магия
        }
        count_sort(p, c); // происходит какая-то странная сорт-ка, которую я еще не осознала

        vi c_new(n); // создаем новый с
        c_new[p[0]] = 0; // распределяем ранги и начинаем с 0го
        forn(i,1,n) {
            // это пары, те самые, я их признала!
            pii prev = {c[p[i-1]], c[(p[i-1] + (1 << k)) % n]}; // распределяем пары с, создаем перд-ий
            pii now  = {c[p[i]],   c[(p[i]   + (1 << k)) % n]}; //и текущий
            if (now == prev) c_new[p[i]] = c_new[p[i-1]]; // если по рангу равны, то оставляем его
            else c_new[p[i]] = c_new[p[i-1]] + 1; // если нет, то повышаем
        }
        c.swap(c_new); // обновляем массив с
        k++; // увел-аем шаг
    }

    return p;
}

void solve() {
    string s;
    cin >> s;

    vector<int> sa = build_sa(s);

    for (int i = 0; i < (int)sa.size(); i++) {
        if (i) cout << " ";
        cout << sa[i];
    }
    cout << en;
}
```
