# Inversions

[Description!](https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/A)

Given a permutation p[] of n elements, find for each i the number of j such that j<i and p[j]>p[i].

[My Solution for C++](https://github.com/kkwwaa/Problem-Solving/blob/main/Trees/Inversions/solution.cpp)
***

## Solution Explanation


<img width="1076" height="755" alt="image" src="https://github.com/user-attachments/assets/a5f4d597-eadc-4e5a-8792-617ac3d56440" />

**Решение использует дерево отрезков для эффективного подсчёта инверсий, отслеживая количество элементов, больших текущего, в перестановке.
Дерево отрезков хранит префиксные суммы массива has. Для каждого p[i] запрашиваем сумму элементов справа от p[i] и обновляем has[p[i]] = 1.**

##Основные шаги

- Создаём массив has размером n+1, заполненный нулями, для отметки обработанных элементов.
- Используем дерево отрезков для хранения префиксных сумм массива has.
- Проходим по перестановке p[] слева направо.
- Для каждого p[i]:
  - Запрос (get): Вычисляем сумму в has на отрезке [p[i]+1, n] с помощью дерева отрезков. Это даёт количество элементов, больших p[i], встреченных ранее (число инверсий).
  - Обновление (update): Устанавливаем has[p[i]] = 1 в дереве отрезков, отмечая, что элемент p[i] обработан.

Операции с деревом отрезков:
- Построение (build): Не требуется, так как дерево изначально пустое (все has[i] = 0).
- Запрос (get): Возвращает сумму на отрезке [p[i]+1, n] для подсчёта инверсий.
- Обновление (update): Устанавливает has[p[i]] = 1 в дереве отрезков.
